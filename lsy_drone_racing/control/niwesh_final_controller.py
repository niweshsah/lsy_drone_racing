"""
MyStateController
Author: Yuming Li
Date: 29.10.2025

Description:
  This controller uses cubic spline interpolation to generate smooth trajectories through waypoints.
It supports dynamic replanning when gates or obstacles change position during flight.
  This controller is a refactored and extended version of the EasyController 
from the LSY Drone Racing project by Yufei Hua (Learning Systems and Robotics Lab, TUM).
It is used solely for learning and research purposes.

Key features:
- Pre-computed trajectory with cubic spline interpolation
- Collision avoidance with obstacles
- Dynamic replanning on environment changes
- Real-time 3D visualization

Original repository:
https://github.com/yufei4hua/lsy_drone_racing

License:
  This file is derived from code released under the MIT License.
  Copyright (c) 2024 Learning Systems and Robotics Lab (LSY)
  See the original license at the above repository for details.
"""
from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
from scipy.interpolate import CubicSpline
from scipy.spatial.transform import Rotation

from lsy_drone_racing.control.controller import Controller
from lsy_drone_racing.utils.utils import draw_line

try:
    import matplotlib.pyplot as plt
except ImportError:
    plt = None

if TYPE_CHECKING:
    from numpy.typing import NDArray


class MyController(Controller):
    """Trajectory-following controller for drone racing.
    
    This controller plans a smooth trajectory through predefined waypoints and tracks it
    over time. It can dynamically replan when the environment changes.
    """

    # Class constants
    TRAJECTORY_DURATION = 15.0  # Total trajectory duration in seconds
    STATE_DIMENSION = 13  # [x, y, z, vx, vy, vz, ax, ay, az, yaw, rrate, prate, yrate]
    OBSTACLE_SAFETY_DISTANCE = 0.3  # Minimum distance to obstacles in meters
    VISUALIZATION_SAMPLES = 100  # Number of points for trajectory visualization
    LOG_INTERVAL = 100  # Print debug info every N ticks

    def __init__(
        self, 
        obs: dict[str, NDArray[np.floating]], 
        info: dict, 
        config: dict
    ):
        """Initialize the controller.

        Args:
            obs: Initial observation containing drone state, gates, and obstacles.
            info: Initial environment information from reset.
            config: Race configuration with environment frequency and settings.
        """
        super().__init__(obs, info, config)
        
        # Controller state
        self._time_step = 0
        self._control_frequency = config.env.freq
        self._is_finished = False
        
        # Environment state tracking for change detection
        self._last_gate_flags = None
        self._last_obstacle_flags = None
        
        # Extract gate information
        self.gate_positions = obs['gates_pos']
        self.gate_normals = self._extract_gate_normals(obs['gates_quat'])
        
        # Extract obstacle information
        self.obstacle_positions = obs['obstacles_pos']
        
        # Initial drone position
        self.initial_position = obs['pos']
        
        # Enable visualization (trajectory plotting)
        self.visualization = False
        
        # Calculate waypoints 
        waypoints = self.calc_waypoints_from_gates(
            self.initial_position,
            self.gate_positions,
            self.gate_normals,
            approach_distance=0.5,
            num_intermediate_points=5
        )
        print(f"Initial waypoints count: {len(waypoints)}")
        print(f"Initial waypoints:\n{waypoints}")
        
        # Apply collision avoidance
        time_params, waypoints = self._avoid_collisions(
            waypoints, 
            self.obstacle_positions,
            self.OBSTACLE_SAFETY_DISTANCE
        )
        print(f"Replanned waypoints count: {len(waypoints)}")
        print(f"Replanned waypoints:\n{waypoints}")
        
        # Generate smooth trajectory
        self.trajectory = self._generate_trajectory(self.TRAJECTORY_DURATION, waypoints)
        
        # Initialize visualization
        self.fig = None
        self.ax = None
        if self.visualization:
            self._visualize_trajectory(
                self.gate_positions,
                self.gate_normals,
                obstacle_positions=self.obstacle_positions,
                trajectory=self.trajectory,
                waypoints=waypoints,
                drone_position=obs['pos']
            )
                # 在 __init__ 中添加调试代码
        print("=== Available info keys ===")
        print(info.keys())
        print("\n=== Available obs keysduide ===")
        print(obs.keys())


    def _extract_gate_normals(self, gates_quaternions: NDArray[np.floating]) -> NDArray[np.floating]:
        """Extract gate normal vectors from quaternions.
        
        Args:
            gates_quaternions: Array of gate orientations as quaternions [w, x, y, z].
            
        Returns:
            Array of gate normal vectors (first column of rotation matrices).
        """
        rotations = Rotation.from_quat(gates_quaternions)
        rotation_matrices = rotations.as_matrix()
        return rotation_matrices[:, :, 0]  # Extract first column (x-axis / normal)

    def calc_waypoints_from_gates(
        self,
        initial_position: NDArray[np.floating],
        gate_positions: NDArray[np.floating],
        gate_normals: NDArray[np.floating],
        approach_distance: float = 0.5,
        num_intermediate_points: int = 5
    ) -> NDArray[np.floating]:
        """Automatically generate waypoints based on gate positions.
        
        Creates multiple waypoints around each gate to ensure smooth passage.
        
        Args:
            initial_position: Starting position of the drone.
            gate_positions: Positions of all gates.
            gate_normals: Normal vectors of all gates.
            approach_distance: Distance before/after gate center for waypoints.
            num_intermediate_points: Number of points to place around each gate.
            
        Returns:
            Array of waypoints including initial position.
        """
        num_gates = gate_positions.shape[0]
        
        # Create waypoints before and after each gate
        waypoints_per_gate = []
        for i in range(num_intermediate_points):
            # Interpolate from -approach_distance to +approach_distance
            offset = -approach_distance + (i / (num_intermediate_points - 1)) * 2 * approach_distance
            waypoints_per_gate.append(gate_positions + offset * gate_normals)
        
        # Reshape to (num_gates * num_intermediate_points, 3)
        waypoints = np.concatenate(waypoints_per_gate, axis=1)
        waypoints = waypoints.reshape(num_gates, num_intermediate_points, 3).reshape(-1, 3)
        
        # Prepend initial position
        waypoints = np.vstack([initial_position, waypoints])
        
        return waypoints

    def _generate_trajectory(
        self, 
        duration: float, 
        waypoints: NDArray[np.floating]
    ) -> CubicSpline:
        """Generate a cubic spline trajectory through waypoints.
        
        Uses arc-length parameterization for more uniform velocity distribution.
        
        Args:
            duration: Total time duration for the trajectory.
            waypoints: Array of 3D waypoints.
            
        Returns:
            CubicSpline object for trajectory evaluation.
        """
        # Calculate segment lengths
        segment_vectors = np.diff(waypoints, axis=0)
        segment_lengths = np.linalg.norm(segment_vectors, axis=1)
        
        # Cumulative arc length
        cumulative_arc_length = np.concatenate([[0], np.cumsum(segment_lengths)])
        
        # Parameterize time by arc length for uniform velocity
        time_parameters = cumulative_arc_length / cumulative_arc_length[-1] * duration
        
        return CubicSpline(time_parameters, waypoints)

    def _avoid_collisions(
        self,
        waypoints: NDArray[np.floating],
        obstacle_positions: NDArray[np.floating],
        safety_distance: float
    ) -> tuple[NDArray[np.floating], NDArray[np.floating]]:
        """Modify trajectory to avoid collisions with obstacles.
        
        Detects trajectory segments that pass too close to obstacles and inserts
        new waypoints to steer around them.
        
        Args:
            waypoints: Original waypoints.
            obstacle_positions: Positions of cylindrical obstacles.
            safety_distance: Minimum safe distance from obstacles.
            
        Returns:
            Tuple of (time_parameters, modified_waypoints).
        """
        # Generate initial trajectory
        trajectory = self._generate_trajectory(self.TRAJECTORY_DURATION, waypoints)
        
        # Sample trajectory at high resolution
        time_samples = np.linspace(0, self.TRAJECTORY_DURATION, 
                                   int(self._control_frequency * self.TRAJECTORY_DURATION))
        trajectory_points = trajectory(time_samples)
        
        # Process each obstacle
        for obstacle_position in obstacle_positions:
            collision_free_times = []
            collision_free_waypoints = []
            
            is_inside_obstacle = False
            entry_index = None
            
            for i, point in enumerate(trajectory_points):
                # Check distance in XY plane only (cylindrical obstacles)
                distance_xy = np.linalg.norm(obstacle_position[:2] - point[:2])
                
                if distance_xy < safety_distance:
                    if not is_inside_obstacle:
                        # First entry into obstacle zone
                        is_inside_obstacle = True
                        entry_index = i
                        
                elif is_inside_obstacle:
                    # Exiting obstacle zone - compute avoidance waypoint
                    exit_index = i
                    is_inside_obstacle = False
                    
                    # Compute new waypoint direction (average of entry and exit directions)
                    entry_point = trajectory_points[entry_index]
                    exit_point = trajectory_points[exit_index]
                    
                    entry_direction = entry_point[:2] - obstacle_position[:2]
                    exit_direction = exit_point[:2] - obstacle_position[:2]
                    avoidance_direction = entry_direction + exit_direction
                    avoidance_direction /= np.linalg.norm(avoidance_direction)
                    
                    # Place new waypoint at safety distance
                    new_position_xy = obstacle_position[:2] + avoidance_direction * safety_distance
                    new_position_z = (entry_point[2] + exit_point[2]) / 2
                    new_waypoint = np.concatenate([new_position_xy, [new_position_z]])
                    
                    # Add at midpoint time
                    collision_free_times.append((time_samples[entry_index] + time_samples[exit_index]) / 2)
                    collision_free_waypoints.append(new_waypoint)
                    
                else:
                    # Point is safe, keep it
                    collision_free_times.append(time_samples[i])
                    collision_free_waypoints.append(point)
            
            # Update for next obstacle
            time_samples = np.array(collision_free_times)
            trajectory_points = np.array(collision_free_waypoints)
        
        return time_samples, trajectory_points

    def _visualize_trajectory(
        self,
        gate_positions: NDArray[np.floating],
        gate_normals: NDArray[np.floating],
        obstacle_positions: NDArray[np.floating] = None,
        trajectory: CubicSpline = None,
        waypoints: NDArray[np.floating] = None,
        drone_position: NDArray[np.floating] = None
    ) -> None:
        """Visualize trajectory, gates, obstacles, and drone in 3D.
        
        Args:
            gate_positions: Positions of gates.
            gate_normals: Normal vectors of gates.
            obstacle_positions: Optional positions of obstacles.
            trajectory: Optional trajectory spline to visualize.
            waypoints: Optional discrete waypoints to visualize.
            drone_position: Optional current drone position.
        """
        if plt is None:
            return  # Matplotlib not available
        
        # Initialize figure if needed
        if self.fig is None:
            plt.ion()
            self.fig = plt.figure(num=1, figsize=(10, 10))
            self.ax = self.fig.add_subplot(111, projection='3d')
        
        self.ax.cla()
        
        # Plot waypoints
        if waypoints is not None:
            self.ax.plot(waypoints[:, 0], waypoints[:, 1], waypoints[:, 2],
                        marker='.', linestyle='--', color='blue', 
                        label='Waypoints', linewidth=1)
        
        # Plot smooth trajectory
        if trajectory is not None:
            t_samples = np.linspace(0, self.TRAJECTORY_DURATION, self.VISUALIZATION_SAMPLES)
            traj_points = trajectory(t_samples)
            self.ax.plot(traj_points[:, 0], traj_points[:, 1], traj_points[:, 2],
                        marker='x', linestyle='-', color='orange',
                        label='Trajectory', markersize=3, linewidth=2)
        
        # Plot gates with normal vectors
        for pos, normal in zip(gate_positions, gate_normals):
            self.ax.quiver(pos[0], pos[1], pos[2],
                          normal[0], normal[1], normal[2],
                          length=0.5, color='green', linewidth=1.5, arrow_length_ratio=0.3)
        
        # Plot obstacles as vertical cylinders
        if obstacle_positions is not None:
            for obs_pos in obstacle_positions:
                self.ax.plot([obs_pos[0], obs_pos[0]], 
                           [obs_pos[1], obs_pos[1]], 
                           [0, 1.4],
                           color='grey', linewidth=5, alpha=0.6)
        
        # Plot drone current position
        if drone_position is not None:
            self.ax.scatter(drone_position[0], drone_position[1], drone_position[2],
                          marker='x', s=200, color='red', linewidths=3,
                          label='Drone')
        
        # Configure plot
        self.ax.set_title("Planned Trajectory Visualization", fontsize=14, fontweight='bold')
        self.ax.set_xlabel("X (m)", fontsize=11)
        self.ax.set_ylabel("Y (m)", fontsize=11)
        self.ax.set_zlabel("Z (m)", fontsize=11)
        self.ax.legend(loc='upper right')
        self.ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.draw()
        plt.pause(0.001)

    def _detect_environment_change(self, obs: dict[str, NDArray[np.bool_]]) -> bool:
        """Detect if any gate or obstacle position has changed.
        
        Uses the 'visited' flags to detect when environment elements are triggered,
        which may indicate position changes in randomized scenarios.
        
        Args:
            obs: Current observation with 'gates_visited' and 'obstacles_visited' flags.
            
        Returns:
            True if a change was detected, False otherwise.
        """
        # Initialize on first call
        if self._last_gate_flags is None:
            self._last_gate_flags = np.array(obs['gates_visited'], dtype=bool)
            self._last_obstacle_flags = np.array(obs['obstacles_visited'], dtype=bool)
            return False
        
        # Check for newly visited gates or obstacles
        current_gate_flags = np.array(obs['gates_visited'], dtype=bool)
        current_obstacle_flags = np.array(obs['obstacles_visited'], dtype=bool)
        
        gate_newly_visited = np.any((~self._last_gate_flags) & current_gate_flags)
        obstacle_newly_visited = np.any((~self._last_obstacle_flags) & current_obstacle_flags)
        
        # Update stored flags
        self._last_gate_flags = current_gate_flags
        self._last_obstacle_flags = current_obstacle_flags
        
        return gate_newly_visited or obstacle_newly_visited

    def _replan_trajectory(self, obs: dict[str, NDArray[np.floating]], current_time: float) -> None:
        """Replan trajectory when environment changes.
        
        Args:
            obs: Current observation with updated gate/obstacle positions.
            current_time: Current time in trajectory for logging.
        """
        print(f"\n[REPLANNING] Time: {current_time:.2f}s")
        
        # Update gate information
        self.gate_normals = self._extract_gate_normals(obs['gates_quat'])
        self.gate_positions = obs['gates_pos']
        
        # Generate new waypoints (could use calc_waypoints_from_gates for automatic generation)
        waypoints = self.calc_waypoints_from_gates(
            self.initial_position ,
            self.gate_positions,
            self.gate_normals,
            approach_distance=0.5,
            num_intermediate_points=5
        )
        print(f"New waypoints count: {len(waypoints)}")
        
        # Apply collision avoidance
        _, waypoints = self._avoid_collisions(
            waypoints,
            obs['obstacles_pos'],
            self.OBSTACLE_SAFETY_DISTANCE
        )
        # self._time_step = 0    
        # Generate new trajectory
        self.trajectory = self._generate_trajectory(self.TRAJECTORY_DURATION, waypoints)
        
        # Update visualization
        # if self.visualization:
        #     self._visualize_trajectory(
        #         self.gate_positions,
        #         self.gate_normals,
        #         obstacle_positions=obs['obstacles_pos'],
        #         trajectory=self.trajectory,
        #         drone_position=obs['pos']
        #     )

    def compute_control(
        self,
        obs: dict[str, NDArray[np.floating]],
        info: dict | None = None
    ) -> NDArray[np.floating]:
        """Compute the next desired state for the drone.
        
        Args:
            obs: Current observation of environment state.
            info: Optional additional information.
            
        Returns:
            13D state vector [x, y, z, vx, vy, vz, ax, ay, az, yaw, rrate, prate, yrate].
            Only position (first 3 elements) is set; rest are zeros for low-level controller.
        """
        # Compute current time along trajectory
        current_time = min(self._time_step / self._control_frequency, self.TRAJECTORY_DURATION)
        
        # Sample target position from trajectory
        target_position = self.trajectory(current_time)
        
        # Periodic logging
        if self._time_step % self.LOG_INTERVAL == 0:
            print(f"Time: {current_time:.2f}s | "
                  f"Target: [{target_position[0]:.3f}, {target_position[1]:.3f}, {target_position[2]:.3f}]")
        
        # Check for environment changes and replan if necessary
        if self._detect_environment_change(obs):
            self._replan_trajectory(obs, current_time)
        if self.visualization:
            self._visualize_trajectory(
                self.gate_positions,
                self.gate_normals,
                obstacle_positions=obs['obstacles_pos'],
                trajectory=self.trajectory,
                drone_position=obs['pos']
            )
        # Check if trajectory is complete
        if current_time >= self.TRAJECTORY_DURATION:
            self._is_finished = True
        
        # Draw trajectory in simulation environment (if available)
        try:
            draw_line(self.env, self.trajectory(self.trajectory.x), 
                     rgba=np.array([1.0, 1.0, 1.0, 0.2]))
        except (AttributeError, TypeError):
            pass  # env not available or draw_line not supported
        
        # Return 13D state with only position filled
        return np.concatenate((target_position, np.zeros(10)), dtype=np.float32)

    def step_callback(
        self,
        action: NDArray[np.floating],
        obs: dict[str, NDArray[np.floating]],
        reward: float,
        terminated: bool,
        truncated: bool,
        info: dict
    ) -> bool:
        """Called after each environment step.
        
        Args:
            action: Action taken.
            obs: Resulting observation.
            reward: Reward received.
            terminated: Whether episode terminated.
            truncated: Whether episode was truncated.
            info: Additional information.
            
        Returns:
            True if controller is finished, False otherwise.
        """
        self._time_step += 1
        return self._is_finished

    # ==================== Utility Methods for External Use ====================
    
    def get_trajectory_function(self) -> CubicSpline:
        """Get the trajectory spline function.
        
        Returns:
            CubicSpline object representing the trajectory.
        """
        return self.trajectory

    def get_trajectory_waypoints(self) -> NDArray[np.floating]:
        """Get discrete waypoints sampled from trajectory at control frequency.
        
        Returns:
            Array of waypoints with shape (num_timesteps, 3).
        """
        time_samples = np.linspace(0, self.TRAJECTORY_DURATION,
                                   int(self._control_frequency * self.TRAJECTORY_DURATION))
        return self.trajectory(time_samples)

    def set_time_step(self, time_step: int) -> None:
        """Set the current time step (for testing/debugging).
        
        Args:
            time_step: New time step value.
        """
        self._time_step = time_step